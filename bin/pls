#!/usr/bin/env bash
# 
# Prima Local Stack

# !!! KEEP THIS FUNCTION ON TOP !!!
_update_script() {
    local random_string
    local url
    _info "Updating script..."
    _info "Saving in $SCRIPT_PATH"
    random_string=$(date +"%s")
    url="$SCRIPT_URL"?ran="$random_string"
    _info "Fetching script from $url"
    if sudo curl -fsSL $url -o "$SCRIPT_PATH"; then
        sudo chmod +x $SCRIPT_PATH
        _info "Update completed!"
        exit
    else
        _error "There was a problem during the update."
    fi
}

readonly DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
readonly USER="$(whoami)"

_help() {
    cat <<HEREDOC

Prima Local Stack
(more on https://kubernetes.io/docs/reference/kubectl/cheatsheet/)

usage: pls <command>

Primo avvio e troubleshooting
    install             Installa pls in locale e configura i vari servizi k8s
    build <services>   Rebuilda i vari container (alias "update", "refresh", "rebuild")
    refresh <services> Ricarica il file kubernetes.yml
    fix                 Sistema i permessi delle cartelle

Database
    dump                Effettua il dump di dati necessari (apikeys, codici istat citt√°, etc) dal db di staging a un file locale
    restore             Carica sul db locale i dati recuperati tramite 'pls dump'

Gestione dell'ambiente locale
    stop                Ferma l'ambiente locale
    start               Avvia l'ambiente locale
    status              Stampa lo status dei servizi (alias "ps", "ss", "ls") 
    reset               Reset completo dell'ambiente locale

Gestione dei servizi
    add <services>      Aggiunge i servizi allo stack locale (ad es: pls add prima hal9000)
    remove <services>   Rimuove i servizi dallo stack locale (alias "rm") (ad es: pls rm prima hal9000)
    restart <services>  Riavvia il servizio

    open <service>      Apre il servizio nel browser
    bash <service>      Entra in bash nel container del servizio (alias "sh")

Altro
    help                Stampa questo messaggio (default)
HEREDOC
}

###
# Config
###

PLS_CFG_DIR=~/.pls
PLS_CFG=$PLS_CFG_DIR/config.rc

_load_cfg() {
    if [ -f $PLS_CFG ] ; then 
        _info "Loading configuration from $PLS_CFG"
        source $PLS_CFG
    fi

    PROJECTS_DIR=${PROJECTS_DIR:-$(readlink -f $DIR/../..)}
    PERSISTENTVOLUMES_DIR=${PERSISTENTVOLUMES_DIR:-/mnt/k8s-pv}
    PLS_DIR=${PLS_DIR:-$PROJECTS_DIR/pls}
    SCRIPT_URL=${SCRIPT_URL:-"https://raw.githubusercontent.com/primait/pls/master/bin/pls"}
    SCRIPT_PATH=${SCRIPT_PATH:-"/usr/local/bin/pls"}
    DUMP_DB_HOST=${DUMP_DB_HOST:-db-prima-aurora-staging.prima.it}
    DUMP_DB_USERNAME=${DUMP_DB_USERNAME:-prima}
    DUMP_DB_PASSWORD=${DUMP_DB_PASSWORD:-}
}

_save_cfg() {
    echo """
PROJECTS_DIR=$PROJECTS_DIR
PLS_CFG_DIR=$PLS_CFG_DIR
PLS_DIR=$PLS_DIR
SCRIPT_URL=$SCRIPT_URL
SCRIPT_PATH=$SCRIPT_PATH
DUMP_DB_HOST=$DUMP_DB_HOST
DUMP_DB_USERNAME=$DUMP_DB_USERNAME
DUMP_DB_PASSWORD=$DUMP_DB_PASSWORD
""" > $PLS_CFG

    _info "Configuration updated!"
}

###
# Utils
###

_info() {
    echo "üí¨  $0: $1"
}

_warn() {
    echo "‚ö†Ô∏è  $0: $1"
}

_error() {
    echo "‚ùå  $0: $1"
}

_find_pod() {
    echo "$(kubectl get pods | awk '{ print $1 }' | grep $1)"
}

_find_pod_containers() {
    local pod
    pod=$(_find_pod $1)
    echo "$(kubectl describe pod $pod | grep "container:" | grep -oP "(.*)-container" --color=never)"
}

_find_service() {
    echo "$(kubectl get services | grep $1)"
}

_find_service_ports() {
    echo "$(_find_service $1 | grep -oP ':[0-9]+\/' | grep -oP '[0-9]+')"
}

_find_urls() {
    for port in $(_find_service_ports $1)
    do
        echo "http://prima.local:$port"
    done
}

###
# Checks
###

_has_requirements() {
    if [ "${PLS_ALLOW_ROOT:-0}" -ne 1 ] && [ "$EUID" -eq 0 ] ;
        then _error "Please do not run as root. If you *really* know what you are doing, set the env variable PLS_ALLOW_ROOT=1. (es. 'sudo PLS_ALLOW_ROOT=1 pls start')"
        exit
    fi

    if ! _has_minikube
        then _error "'minikube' is not installed. See: https://github.com/primait/board/wiki/Kubernetes"
        exit
    fi
}

_has_minikube() {
    minikube > /dev/null
    [[ $? == 0 ]]
}

_has_pls() {
    [ -x "$(command -v pls)" ]
}

_has_systemd_resolved() {
    sudo systemctl status systemd-resolved -q > /dev/null
    [[ $? == 0 ]]
}

###
# Commands
###

_install() {
    _setup
    _start
    _build
    _fix_k8s_permissions
    _info """

Everything should be set up and running. Now you can add services with 'pls add *service*'. Try with 'pls add prima'! üëèüëè

‚¨áÔ∏è PLS READ ‚¨á

Just one more thing: you should add in your /etc/hosts file the following line

127.0.0.1   prima.local

Note that if you are using another machine you should change 127.0.0.1 with its public IP instead.

‚¨ÜÔ∏è PLS READ ‚¨ÜÔ∏è"
}

_setup() {
    _info "Creating configuration directory '$PLS_CFG_DIR'"
    mkdir -p $PLS_CFG_DIR

    read -p "Where are your projects located? [$PROJECTS_DIR]: " projects_dir
    PROJECTS_DIR=${projects_dir:-$PROJECTS_DIR}

    read -p "Where should the persistent volumes be saved? [$PERSISTENTVOLUMES_DIR]: " persistentvolumes_dir
    PERSISTENTVOLUMES_DIR=${persistentvolumes_dir:-$PERSISTENTVOLUMES_DIR}

    _save_cfg
    _load_cfg
}

_build() {
    local project
    local projects

    projects="$@"
    if [ -z $projects ] ; then
        projects="prima peano borat bburago hal9000 roger"
    fi

    cd $PROJECTS_DIR

    for project in $projects
    do

        case $project in
        prima)
            docker build prima/app/docker/web/dev/ -t prima-nginx:dev
            docker build prima/app/docker/php/ -t prima-php:dev
            ;;
        *) 
            docker build $project/ -t $project:dev
            ;;
        esac
    done

    cd -
}

_refresh_infrastructure() {
    local kube_dir
    kube_dir=$PLS_CFG_DIR/kubernetes

    mkdir -p $kube_dir

    cd $kube_dir
    sed  -e "s|{PERSISTENTVOLUMES_DIR}|$PERSISTENTVOLUMES_DIR|" $PLS_DIR/infrastructure.yml.dist > infrastructure.yml
    
    kubectl apply -f $kube_dir/infrastructure.yml
}

_refresh_service() {

    if [ ! -z $@ ]; then
        projects="$@"
        for project in $projects
        do
            _remove $project
            
            cd $PROJECTS_DIR/$project
            rm kubernetes.yml

            _add $project
        done
    else
        _error "Usage: pls refresh *services"
    fi
}

_add() {
    _refresh_infrastructure

    if [ ! -z $@ ]; then
        for project in "$@"
        do
            cd $PROJECTS_DIR
            PROJECT_DIR=$PROJECTS_DIR/$project
            if [[ ! -d "$PROJECT_DIR" ]]; then
                echo "Project not found locally. Attempting to fetch it from repository..."
                git clone git@github.com:primait/$project.git $PROJECT_DIR
            fi

            cd $PROJECT_DIR 
            if [[ ! -f "$PROJECT_DIR/kubernetes.yml" ]]; then
                echo "kubernetes.yml not found. Generating..."
                sed  -e "s|{HOME}|$HOME|" -e "s|{PROJECTS_HOME}|$PROJECTS_DIR|" kubernetes.yml.dist > kubernetes.yml
            fi

            _build $project

            kubectl apply -f kubernetes.yml

            echo ""

            _urls $project
        done
    else
        _error "Usage: pls add *services"
    fi
}

_remove() {
    _refresh_infrastructure

    if [ ! -z $@ ]; then
        for project in "$@"
        do
            PROJECT_DIR=$PROJECTS_DIR/$project
            if [[ -d "$PROJECT_DIR" ]]; then
                cd $PROJECT_DIR ;\
                kubectl delete -f kubernetes.yml
            else
                _error "$PROJECT_DIR does not existü§∑"
            fi
        done
    else
        _error "Usage: pls remove *services"
    fi
}

_fix_k8s_permissions() {
    sudo chown $USER:$USER ~/.kube/ -R
    sudo chown $USER:$USER ~/.minikube/ -R
}

_dump() {
    local output
    local db_password
    local should_save
    local dump_dir

    dump_dir=$PLS_CFG_DIR/dump

    mkdir -p $dump_dir

    if [ -z $DUMP_DB_PASSWORD ] ; then
        while [ -z $DUMP_DB_PASSWORD ] ; do
            read -sp "Enter password for $DUMP_DB_USERNAME@$DUMP_DB_HOST: " db_password
            DUMP_DB_PASSWORD=$db_password

            echo ""

            if [ ! -z $DUMP_DB_PASSWORD ] ; then
                read -p "Should I save this password locally? (y/N): " should_save
                if [[ "y" == $(echo $should_save | tr A-Z a-z)  ]] ; then
                    _save_cfg
                else
                    _info "Password not saved"
                fi
            fi
        done
    else
        _info "Using password saved in configuration files..."
    fi

    output=$dump_dir/prima_data.sql

    _info "Dumping table struct from database 'prima' ($DUMP_DB_USERNAME@$DUMP_DB_HOST) into $output" ;\
    mysqldump prima --single-transaction -h $DUMP_DB_HOST -u $DUMP_DB_USERNAME --password=$DUMP_DB_PASSWORD --no-data > $output
    
    _info "Dumping data from database 'prima' ($DUMP_DB_USERNAME@$DUMP_DB_HOST) into $output" ;\
    mysqldump prima --single-transaction -h $DUMP_DB_HOST -u $DUMP_DB_USERNAME --password=$DUMP_DB_PASSWORD \
    bo_operator \
    user_configuration \
    security_apikey \
    company \
    criteria_data \
    criteria_group \
    criteria_value \
    document_type \
    document_type_category \
    document_type_type_category \
    guarantee \
    guarantee_deductible \
    guarantee_limit \
    occupation \
    place_city \
    place_city_zip_code \
    place_country \
    place_province \
    place_region \
    place_zip_code \
    place_zone \
    pricer_config \
    pricer_discount \
    pricer_discount_code \
    pricer_guarantee_formula \
    migration_versions >> $output

    # Overwrite api keys to default values
    echo "
    UPDATE prima.security_apikey SET apikey = 'frontendapikey' WHERE operator_id = 3;
    UPDATE prima.security_apikey SET apikey = 'backofficeapikey' WHERE operator_id = 4;" >> $output

    _info "Prima data dumped in '$output'. Now you can restore your local database with 'pls restore'."

    # printf "Dump borat data:\n" ;
    # borat_data.sql
}
    
_restore() {
    printf "Restoring mysql data:\n" ;\
    mysql -u prima --password=prima --port 32306 -h 127.0.0.1 prima < $PLS_CFG_DIR/dump/prima_data.sql

    # printf "Restore borat data:\n" ;\
    # borat_data.sql
}

_deployments() {
    printf "\nDeployments:\n" ;\
    kubectl get deployments --all-namespaces
}

_services() {
    printf "\nServices:\n" ;\
    kubectl get services
}

_pods() {
    printf "\nPods:\n" ;\
    kubectl get pods
}

_status() {
    _deployments
    _services
    _pods
}

_stop() {
    sudo minikube stop
}

_start() {
    if _has_systemd_resolved; then
        sudo minikube start --apiserver-ips=127.0.0.1 --apiserver-name=localhost --vm-driver=none --extra-config=kubelet.resolv-conf=/run/systemd/resolve/resolv.conf
    else
        _warn "systemd-resolved not detected"
        sudo minikube start --apiserver-ips=127.0.0.1 --apiserver-name=localhost --vm-driver=none
    fi
}

_restart() {
    if [ ! -z $@ ]; then
        for project in "$@"
        do
            POD_NAME=$(_find_pod $project)
            if [ ! -z "${POD_NAME}" ]; then
                _info "Restarting $POD_NAME"
                kubectl delete pod $POD_NAME
            else
                _error "Service not found: $project"
            fi
        done
    else
        _error "Usage: prima restart *services*"
    fi
}

_open() {
    local urls
    local url_cnt
    local url_chosen

    if [ ! -z $1 ]; then
        urls=$(_find_urls $1)
        url_cnt=0
        for url in $urls
        do
            url_cnt=$(($url_cnt+1))
        done

        if [[ ${url_cnt} -gt 1 ]]; then
            echo "Multiple URLs detected. Which one should I open?"

            while [ -z $url_chosen ] 
            do
                select url in $urls;
                do
                    url_chosen=$url
                    break
                done

                if [ -z $url_chosen ]
                then
                    _warn "Please choose a valid option"
                fi
            done
        else
            url=$urls
        fi

        _info "Opening $url"
            
        case "$OSTYPE" in
            darwin*) open $url ;;
            linux*) xdg-open $url ;;
            *) echo "Unknown OS $OSTYPE" ;;
        esac
    else
        _error "Usage: pls open *service*"
    fi
}

_bash() {
    local containers
    local container
    local container_chosen

    if [ ! -z $1 ]; then
        POD_NAME=$(_find_pod $1)
        if [ ! -z "${POD_NAME}" ]; then
            _info "Entering pod $POD_NAME"

            if [[ $2 ]]; then
                container_chosen=$1-$2-container
            else
                containers=$(_find_pod_containers $POD_NAME)
                container_cnt=0
                for container in $containers
                do
                    container_cnt=$(($container_cnt+1))
                done

                if [[ ${container_cnt} -gt 1 ]]; then
                    echo "Multiple pod containers detected. Which one should I enter?"

                    while [ -z $container_chosen ] 
                    do
                        select container in $containers;
                        do
                            container_chosen=$container
                            break
                        done

                        if [ -z $container_chosen ]
                        then
                            _warn "Please choose a valid option"
                        fi
                    done
                else
                    container_chosen=$containers
                fi
            fi

            echo "Entering container $container_chosen"
            kubectl exec -it $POD_NAME --container $container_chosen -- bash
        else
            _error "Service not found: $1"
        fi
    else
        _error "Usage: pls bash *service* *container?*"
    fi
}

_logs() {
    if [ ! -z $1 ]; then
        POD_NAME=$(_find_pod $1)
        if [ ! -z "${POD_NAME}" ]; then
            _info "Following $POD_NAME"
            kubectl logs -f $POD_NAME --all-containers=true
        else
            _error "Service not found: $1"
        fi
    else
        _error "Usage: pls log *service*"
    fi
}

_inspect() {
    if [ ! -z $1 ]; then
        POD_NAME=$(_find_pod $1)
        echo $POD_NAME
        if [ ! -z "${POD_NAME}" ]; then
            _info "Inspecting $POD_NAME"
            kubectl describe pod $POD_NAME
        else
            _error "Service not found: $1"
        fi
    else
        _error "Usage: pls inspect *service*"
    fi
}

_reset() {
    local proceed

    read -p "This will delete all pods, services and deployments. Are you sure you want to reset? Type 'yes' to proceed: " proceed

    if [[ "yes" == $(echo $proceed | tr A-Z a-z) ]] ; then
        kubectl delete deployment --all
    else
        _warn "Reset cancelled."
    fi
}

_urls() {
    if [ ! -z $1 ]; then
        echo "$1 available at:"
        _find_urls $1
    else
        _error "Usage: pls url *service*"
    fi
}

_kys() {
    echo "You first"
}

###
# MAIN
###

_main() {
    _load_cfg
    _has_requirements

    COMMAND=$(echo $1 | tr A-Z a-z)
    shift

    if [[ install != $COMMAND ]] && ! _has_pls
        then _error "'pls' is not installed locally. Pls run 'pls install' first."
        exit
    fi

    case $COMMAND in
        # Setup/Troubleshooting

        build|rebuild)
            _build $@
            ;;

        refresh)
            _refresh_service $@
            ;;

        install)
            _install
            ;;

        update)
            _update_script
            ;;

        fix)
            _fix_k8s_permissions
            ;;

        # K8S management

        start)
            _start
            ;;

        stop)
            _stop
            ;;

        reset)
            _reset
            ;;

        # Services management

        add|up)
            _add $@
            ;;

        remove|rm|down)
            _remove $@
            ;;

        open)
            _open $@
            ;;

        bash|sh)
            _bash $@
            ;;

        restart)
            _restart $@
            ;;
            
        urls|url)
            _urls $@
            ;;

        # Debugging

        status|ls|ps|ss)
            _status
            ;;

        logs|log)
            _logs $@
            ;;

        inspect|describe)
            _inspect $@
            ;;

        # Kubernetes

        deployments)
            _deployments
            ;;

        services)
            _services
            ;;

        pods)
            _pods
            ;;

        # DB
        
        dump)
            _dump
            ;;
        
        restore)
            _restore
            ;;

        # Misc

        die|kys)
            _kys
            ;;

        ""|help|--help|-h)
            _help
            ;;

        *)
            _error "$COMMAND is not a valid command. Use 'pls help'."
            ;;
    esac
}

_main $@
