#!/usr/bin/env bash
# prima
# 
# CLI utility for a local Prima local stack

# !!!KEEP THIS ON TOP!!!
_update() {
    local random_string
    local url
    _info "Updating script..."
    _info "Saving in $SCRIPT_PATH"
    random_string=$(date +"%s")
    url="${SCRIPT_URL}"?ran="${random_string}"
    _info "Fetching script from ${url}"
    if sudo curl -fsSL ${url} -o "$SCRIPT_PATH"; then
        sudo chmod +x $SCRIPT_PATH
        _info "Update completed!"
        exit
    else
        _error "There was a problem during the update."
    fi
}

readonly DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
readonly USER="$(whoami)"
readonly PLS_CFG_DIR=~/.pls
readonly PLS_CFG=$PLS_CFG_DIR/config.rc

###
# Config
###

_load_cfg() {
    if [ -f $PLS_CFG ] ; then 
        _info "Loading configuration from $PLS_CFG"
        source $PLS_CFG
    fi

    PROJECTS_DIR=${PROJECTS_DIR:-$(readlink -f $DIR/../..)}
    PERSISTENTVOLUMES_DIR=${PERSISTENTVOLUMES_DIR:-/mnt/k8s-pv}
    PLS_DIR=${PLS_DIR:-$PROJECTS_DIR/pls}
    SCRIPT_URL=${SCRIPT_URL:-"https://raw.githubusercontent.com/primait/pls/master/bin/pls"}
    SCRIPT_PATH=${SCRIPT_PATH:-"/usr/local/bin/pls"}
    DUMP_DB_HOST=${DUMP_DB_HOST:-db-prima-aurora-staging.prima.it}
    DUMP_DB_USERNAME=${DUMP_DB_USERNAME:-prima}
    DUMP_DB_PASSWORD=${DUMP_DB_PASSWORD:-}
}

_save_cfg() {
    echo """
PROJECTS_DIR=$PROJECTS_DIR
PLS_DIR=$PLS_CFG_DIR
SCRIPT_URL=$SCRIPT_URL
SCRIPT_PATH=$SCRIPT_PATH
DUMP_DB_HOST=$DUMP_DB_HOST
DUMP_DB_USERNAME=$DUMP_DB_USERNAME
DUMP_DB_PASSWORD=$DUMP_DB_PASSWORD
""" > $PLS_CFG

    _info "Configuration updated!"
}

###
# Utils
###

_help() {
    cat <<HEREDOC

Prima Local Stack
(more on https://kubernetes.io/docs/reference/kubectl/cheatsheet/)

usage: pls <command>

Primo avvio e troubleshooting
    install             Installa pls in locale e configura i vari servizi k8s
    build <services?>   Rebuilda i vari container (alias "update", "refresh", "rebuild")
    fix                 Sistema i permessi delle cartelle

Database
    dump                Effettua il dump di dati necessari (apikeys, codici istat citt√°, etc) dal db di staging a un file locale
    restore             Carica sul db locale i dati recuperati tramite 'pls dump'

Gestione dell'ambiente locale
    stop                Ferma l'ambiente locale
    start               Avvia l'ambiente locale
    status              Stampa lo status dei servizi (alias "ps")
    services            Stampa la lista dei servizi (alias "ls", "ss")
    reset               Reset completo dell'ambiente locale

Gestione dei servizi
    add <services>      Aggiunge i servizi allo stack locale (ad es: pls add prima hal9000)
    remove <services>   Rimuove i servizi dallo stack locale (alias "rm") (ad es: pls rm prima hal9000)
    restart <services>  Riavvia il servizio

    open <service>      Apre il servizio nel browser
    bash <service>      Entra in bash nel container del servizio (alias "sh")

Altro
    help                Stampa questo messaggio (default)
HEREDOC
}

_info() {
    echo "üí¨  $0: $1"
}

_warning() {
    echo "‚ö†Ô∏è  $0: $1"
}

_error() {
    echo "‚ùå  $0: $1"
}

_find_pod() {
    if [[ $1 ]]; then
        POD_NAME="$(kubectl get pods | awk '{ print $1 }' | grep $1)"
        if [[ ${POD_NAME} ]]; then
            echo ${POD_NAME}
        else
            _error "No service '$1' found"
            echo
        fi
    else 
        _error "No service specified"
    fi
}

_find_service() {
    echo "$(kubectl get services | grep $1)"
}

_find_service_ports() {
    echo "$(_find_service $1 | grep -oP ':[0-9]+\/' | grep -oP '[0-9]+')"
}

_check_requirements() {
    if [ "${PLS_ALLOW_ROOT:-0}" -ne 1 ] && [ "${EUID}" -eq 0 ] ;
        then _error "Please do not run as root. If you *really* know what you are doing, set the env variable PLS_ALLOW_ROOT=1. (es. 'sudo PLS_ALLOW_ROOT=1 pls start')"
        exit
    fi

    if ! _has_minikube
        then _error "'minikube' is not installed. See: https://github.com/primait/board/wiki/Kubernetes-experiments"
        exit
    fi
}

_has_minikube() {
    minikube > /dev/null
    [[ $? == 0 ]]
}

_has_pls() {
    [ -x "$(command -v pls)" ]
}

_has_systemd_resolved() {
    sudo systemctl status systemd-resolved -q > /dev/null
    [[ $? == 0 ]]
}

###
# Commands
###

_install() {
    _setup
    _update
    _start
    _build
    _fix_k8s_permissions
    _info "Everything should be set up and running. Now you can add services with 'pls add *service*'. Try with 'pls add prima'! üëèüëè"
}

_setup() {
    _info "Creating configuration directory '$PLS_CFG_DIR'"
    mkdir -p $PLS_CFG_DIR

    read -p "Where are your projects located? [$PROJECTS_DIR]: " projects_dir
    PROJECTS_DIR=${projects_dir:-$PROJECTS_DIR}

    read -p "Where should the persistent volumes be saved? [$PERSISTENTVOLUMES_DIR]: " persistentvolumes_dir
    PERSISTENTVOLUMES_DIR=${persistentvolumes_dir:-$PERSISTENTVOLUMES_DIR}

    _save_cfg
    _load_cfg
}

_build() {
    local project
    local projects

    projects="$@"
    if [ -z $projects ] ; then
        projects="prima peano borat bburago hal9000 roger"
    fi

    cd ${PROJECTS_DIR}
    for project in $projects
    do

        case $project in
        prima)
            docker build prima/app/docker/web/dev/ -t prima-nginx:dev
            docker build prima/app/docker/php/ -t prima-php:dev
            ;;
        *) 
            docker build $project/ -t $project:dev
            ;;
        esac
    done

    cd -
}

_refresh_infrastructure() {
    local kube_dir
    kube_dir=$PLS_CFG_DIR/kubernetes

    mkdir -p $kube_dir

    cd $kube_dir

    if [[ ! -f "infrastructure.yml" ]] || [[ ! -s "infrastructure.yml" ]]; then
        sed  -e "s|{PERSISTENTVOLUMES_DIR}|$PERSISTENTVOLUMES_DIR|" $PLS_DIR/infrastructure.yml.dist > infrastructure.yml
    fi
    
    kubectl apply -f $kube_dir/infrastructure.yml
}

_add() {
    _refresh_infrastructure

    for project in "$@"
    do
        cd $PROJECTS_DIR
        PROJECT_DIR=${PROJECTS_DIR}/$project
        if [[ ! -d "$PROJECT_DIR" ]]; then
            echo "Project not found locally. Attempting to fetch it from repository..."
            git clone git@github.com:primait/$project.git $PROJECT_DIR
        fi

        cd ${PROJECT_DIR} 
        if [[ ! -f "${PROJECT_DIR}/kubernetes.yml" ]]; then
            echo "kubernetes.yml not found. Generating..."
            sed  -e "s|{HOME}|$HOME|" -e "s|{PROJECTS_HOME}|$PROJECTS_DIR|" kubernetes.yml.dist > kubernetes.yml
        fi

        _build $project

        kubectl apply -f kubernetes.yml
    done
}

_remove() {
    _refresh_infrastructure

    for project in "$@"
    do
        PROJECT_DIR=${PROJECTS_DIR}/$project
        if [[ -d "$PROJECT_DIR" ]]; then
            cd ${PROJECT_DIR} ;\
            kubectl delete -f kubernetes.yml
        else
            _error "$PROJECT_DIR does not existü§∑"
        fi
    done
}

_fix_k8s_permissions() {
    sudo chown ${USER}:${USER} ~/.kube/ -R
    sudo chown ${USER}:${USER} ~/.minikube/ -R
}

_dump() {
    local output
    local db_password
    local should_save
    
    if [ -z $DUMP_DB_PASSWORD ] ; then
        while [ -z $DUMP_DB_PASSWORD ] ; do
            read -sp "Enter password for $DUMP_DB_USERNAME@$DUMP_DB_HOST: " db_password
            DUMP_DB_PASSWORD=$db_password

            echo ""

            if [ ! -z $DUMP_DB_PASSWORD ] ; then
                read -p "Should I save this password locally? (y/N): " should_save
                if [[ "y" == $(echo $should_save | tr A-Z a-z)  ]] ; then
                    _save_cfg
                else
                    _info "Password not saved"
                fi
            fi
        done
    else
        _info "Using password saved in configuration files..."
    fi

    output=$PLS_CFG_DIR/dump/prima_data.sql

    _info "Dumping data from database 'prima' ($DUMP_DB_USERNAME@$DUMP_DB_HOST) into $output" ;\
    mysqldump prima --single-transaction -h ${DUMP_DB_HOST} -u ${DUMP_DB_USERNAME} --password=$DUMP_DB_PASSWORD \
    bo_operator \
    user_configuration \
    security_apikey \
    company \
    criteria_data \
    criteria_group \
    criteria_value \
    document_type \
    document_type_category \
    document_type_type_category \
    guarantee \
    guarantee_deductible \
    guarantee_limit \
    occupation \
    place_city \
    place_city_zip_code \
    place_country \
    place_province \
    place_region \
    place_zip_code \
    place_zone \
    pricer_config \
    pricer_discount \
    pricer_discount_code \
    pricer_guarantee_formula > $output

    _info "Prima data dumped in '$output'. Use it to restore your local database with 'pls restore'."

    # printf "Dump borat data:\n" ;
    # borat_data.sql
}
    
_restore() {
    printf "Restoring mysql data:\n" ;\
    mysql -u prima --password=prima --port 32306 -h 127.0.0.1 prima < $PLS_CFG_DIR/dump/prima_data.sql

    # printf "Restore borat data:\n" ;\
    # borat_data.sql
}

_status() {
    printf "Deployments:\n" ;\
    kubectl get deployments --all-namespaces ;\
    
    printf "\nServices:\n" ;\
    kubectl get services
    
    printf "\nPods:\n" ;\
    kubectl get pods
}

_stop() {
    sudo minikube stop
}

_start() {
    if _has_systemd_resolved; then
        sudo minikube start --apiserver-ips=127.0.0.1 --apiserver-name=localhost --vm-driver=none --extra-config=kubelet.resolv-conf=/run/systemd/resolve/resolv.conf
    else
        _warning "systemd-resolved not detected"
        sudo minikube start --apiserver-ips=127.0.0.1 --apiserver-name=localhost --vm-driver=none
    fi
}

_restart() {
    for project in "$@"
    do
        POD_NAME=$(_find_pod $project)
        if [[ ${POD_NAME} ]]; then
            _info "Restarting $POD_NAME"
            kubectl delete pod ${POD_NAME}
        fi
    done
}

_open() {
    local ports
    local port
    local url

    ports=$(_find_service_ports $1)
    if [[ ${#ports} -gt 5 ]]; then
        echo "Multiple service ports detected. Which one should I open?"

        select port in $ports;
        do
            port=$port
            break
        done
    else
        port=$ports
    fi

    if [[ $port ]]; then
        url="http://prima:$port/"
        _info "Opening $url"
          
        case "$OSTYPE" in
            darwin*) open $url ;;
            linux*) xdg-open $url ;;
            *) echo "Unknown OS $OSTYPE" ;;
        esac
    else
        _error "$1 not found. Try to see if it's listed with 'pls ss'."
    fi
}

_bash() {
    POD_NAME=$(_find_pod $1)
    if [[ ${POD_NAME} ]]; then
        _info "Entering $POD_NAME"
        if [[ $2 ]]; then
            kubectl exec -it ${POD_NAME} --container $1-$2-container -- bash
        else
            kubectl exec -it ${POD_NAME} bash
        fi
    fi
}

_logs() {
    POD_NAME=$(_find_pod $1)
    if [[ ${POD_NAME} ]]; then
        _info "Following $POD_NAME"
        kubectl logs -f ${POD_NAME} --all-containers=true
    fi
}

_inspect() {
    POD_NAME=$(_find_pod $1)
    if [[ ${POD_NAME} ]]; then
        _info "Inspecting $POD_NAME"
        kubectl describe pod ${POD_NAME}
    fi
}

_reset() {
    local proceed

    read -p "This will delete all pods, services and deployments. Are you sure you want to reset? Type 'yes' to proceed: " proceed

    if [[ "yes" == $(echo $proceed | tr A-Z a-z) ]] ; then
        kubectl delete deployment --all
    else
        _warning "Reset cancelled."
    fi
}

_urls() {
    echo "$1 exposed at:"
    for port in $(_find_service_ports $1)
    do
        echo "http://prima:$port"
    done
}

_kys() {
    echo "You first"
}

###
# MAIN
###

_main() {
    _load_cfg
    _check_requirements

    COMMAND=$(echo $1 | tr A-Z a-z)
    shift

    if [[ install != ${COMMAND} ]] && ! _has_pls
        then _error "'pls' is not installed locally. Pls run 'pls install' first."
        exit
    fi

    case ${COMMAND} in
        # Setup/Troubleshooting

        build|rebuild|refresh)
            _build $@
            ;;

        install)
            _install
            ;;

        update)
            _update
            ;;

        fix)
            _fix_k8s_permissions
            ;;

        # K8S management

        start)
            _start
            ;;

        stop)
            _stop
            ;;

        reset)
            _reset
            ;;

        # Services management

        add|up)
            _add $@
            ;;

        remove|rm|down)
            _remove $@
            ;;

        open)
            _open $@
            ;;

        bash|sh)
            _bash $@
            ;;

        restart)
            _restart $@
            ;;
            
        urls|url)
            _urls $@
            ;;

        # Debugging

        status|services|ls|ps|ss)
            _status
            ;;

        logs|log)
            _logs $@
            ;;

        inspect|describe)
            _inspect $@
            ;;

        # DB
        
        dump)
            _dump
            ;;
        
        restore)
            _restore
            ;;

        # Misc

        die|kys)
            _kys
            ;;

        ""|help|--help|-h)
            _help
            ;;

        *)
            _error "$COMMAND is not a valid command. Use 'pls help'."
            ;;
    esac
}

_main $@
